<!DOCTYPE html>
<html lang="ru" class="h-full">
<head>
    <meta charset="UTF-8"> <!-- ИСПРАВЛЕНО: Было UTF-M -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Лаборатория хаоса</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- ИЗМЕНЕНО: Удален импорт Google Fonts -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" defer></script>
    
    <style>
        /* Стиль для темной темы и шрифта */
        html, body { /* ИЗМЕНЕНО: Применяем к html и body для большей надежности в Safari */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            height: 100%; margin: 0; padding: 0; overflow: hidden; /* УБИРАЕТ СКРОЛЛ СТРАНИЦЫ */
        }
        .bg-gray-900 { background-color: #111827; }
        .bg-gray-800 { background-color: #1F2937; }
        .bg-gray-700 { background-color: #374151; }
        .text-gray-200 { color: #E5E7EB; }
        .text-gray-400 { color: #9CA3AF; }
        .border-gray-700 { border-color: #374151; }
        
        /* Стили для ползунков */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #374151; /* bg-gray-700 */
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #60A5FA; /* bg-blue-400 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #60A5FA;
            border-radius: 50%;
            cursor: pointer;
        }
        /* Стиль для активной кнопки модели */
        .model-button.active {
            background-color: #3B82F6; /* bg-blue-600 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 h-full flex flex-col">

    <!-- Заголовок -->
    <header class="p-6 border-b border-gray-700 bg-gradient-to-r from-slate-900 to-slate-800">
        <h1 class="text-2xl md:text-3xl font-bold flex justify-between items-center gap-3">
          <!-- Левая часть: иконка + название -->
          <div class="flex items-center gap-3">      
            <!-- Название с градиентом -->
            <span class="bg-gradient-to-r from-cyan-400 to-blue-500 bg-clip-text text-transparent 
                         drop-shadow-sm hover:from-cyan-300 hover:to-blue-400 transition-all duration-300">
              Цифровая лаборатория: динамический хаос.
            </span>
          </div>
          <!-- Правая часть: автор -->
          <span class="text-sm text-gray-400 font-medium tracking-wide">
            А.Нурутдинов ©
          </span>
        </h1>
    </header>

    <!-- Основной макет -->
    <main class="flex flex-1 overflow-hidden">
        
        <!-- Левая панель: Управление -->
        <aside class="w-1/5 p-4 border-r border-gray-700 overflow-y-auto">
            <h2 class="text-lg mb-4">Панель управления</h2>
            
            <!-- Выбор модели -->
            <div class="mb-4">
                <h3 class="text-md mb-2">1. Выбор модели</h3>
                <div class="flex flex-col space-y-2">
                    <button id="btn-model-driven" class="model-button w-full text-left p-3 rounded-lg bg-gray-800 hover:bg-gray-700 transition-colors" data-model="driven">
                        Приводной маятник ($\lambda < 0$)
                    </button>
                    <button id="btn-model-simple" class="model-button w-full text-left p-3 rounded-lg bg-gray-800 hover:bg-gray-700 transition-colors" data-model="simple">
                        Простой маятник ($\lambda = 0$)
                    </button>
                    <button id="btn-model-double" class="model-button w-full text-left p-3 rounded-lg bg-gray-800 hover:bg-gray-700 transition-colors" data-model="double">
                        Двойной маятник ($\lambda > 0$)
                    </button>
                    <button id="btn-model-double-damped" class="model-button w-full text-left p-3 rounded-lg bg-gray-800 hover:bg-gray-700 transition-colors" data-model="double_damped">
                        Приводной двойной ($\lambda \lessgtr 0$)
                    </button>
                </div>
            </div>

            <!-- Параметры модели -->
            <div class="mb-4">
                <h3 class="text-md mb-2">2. Параметры</h3>
                <div id="params-container" class="space-y-3">
                    <!-- Параметры будут загружены здесь -->
                </div>
            </div>

            <!-- Управление симуляцией -->
            <div class="mb-4">
                <h3 class="text-md mb-2">3. Управление</h3>
                
                <div class="mb-3 space-y-3">
                    <div class="flex justify-between items-center">
                        <label for="speed-slider" class="text-sm text-gray-400">Скорость</label>
                        <span id="speed-value" class="text-sm text-gray-200 w-12 text-right">x1.0</span>
                    </div>
                    <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1" class="w-full">
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <button id="start-button" class="p-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors">Старт</button>
                    <button id="stop-button" class="p-3 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">Стоп</button>
                    <button id="reset-button" class="p-3 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">Сброс</button>
                    <button id="perturb-button" class="p-3 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">Возмущение</button>
                </div>
                
                <div class="mt-4 space-y-3">
                    <div class="flex justify-between items-center">
                        <label for="perturb-slider" class="text-sm text-gray-400">Вел. возмущения</label>
                        <span id="perturb-value" class="text-sm text-gray-200 w-12 text-right">0.1</span>
                    </div>
                    <input type="range" id="perturb-slider" min="0.01" max="0.5" step="0.01" value="0.1" class="w-full">
                </div>

            </div>
        </aside>

        <!-- Центральная панель: Симуляция и График -->
        <section class="flex-1 flex flex-col p-4 overflow-hidden">
            
            <!-- Окно симуляции (2/3 высоты) -->
            <div id="simulation-wrapper" class="w-full h-2/3 flex space-x-4 bg-gray-800 rounded-lg p-4">
                <!-- Эталонная модель -->
                <div class="flex-1 h-full relative border border-gray-700 rounded-lg">
                    <canvas id="canvas-ref" class="w-full h-full"></canvas>
                    <span class="absolute top-2 left-2 text-sm text-gray-400 bg-gray-800 px-2 py-1 rounded">Эталон</span>
                </div>
                <!-- Модель с возмущением -->
                <div class="flex-1 h-full relative border border-gray-700 rounded-lg">
                    <canvas id="canvas-pert" class="w-full h-full"></canvas>
                    <span class="absolute top-2 left-2 text-sm text-gray-400 bg-gray-800 px-2 py-1 rounded">Симуляция</span>
                </div>
            </div>

            <!-- Нижняя часть (1/3 высоты) -->
            <div class="w-full h-1/3 flex mt-4 space-x-4">
                
                <!-- Окно графика (2/3 ширины) -->
                <div class="w-2/3 h-full bg-gray-800 rounded-lg p-4 flex flex-col">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-lg">График рассинхронизации ($\Delta$)</h2>
                        <div id="diff-value-display" class="text-sm text-gray-400 mb-2">$\Delta = 0.000$</div>
                        <div class="flex items-center space-x-2">
                            <label for="autoscale-checkbox" class="text-sm text-gray-400">Автомасштаб</label>
                            <input type="checkbox" id="autoscale-checkbox" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 rounded text-blue-500 focus:ring-blue-500">
                        </div>
                    </div>
                    <div class="flex-1 relative">
                        <canvas id="diff-chart"></canvas>
                    </div>
                </div>

                <!-- Окно описания (1/3 ширины) -->
                <div id="description-panel" class="w-1/3 h-full bg-gray-800 rounded-lg p-4 overflow-y-auto">
                    <!-- Описание будет загружено здесь -->
                </div>
            </div>

        </section>
    </main>
    
    <script type="module">
        (function() {
            // --- Инициализация KaTeX ---
            function renderMath() {
                try {
                    // Проверка с таймаутом, чтобы дождаться загрузки KaTeX
                    if (typeof window.renderMathInElement === 'function') {
                        window.renderMathInElement(document.body, {
                            delimiters: [
                                {left: "$$", right: "$$", display: true},
                                {left: "$", right: "$", display: false},
                                {left: "\\(", right: "\\)", display: false},
                                {left: "\\[", right: "\\]", display: true}
                            ],
                            throwOnError: false
                        });
                    } else {
                        // KaTeX еще не загружен, пробуем снова
                        setTimeout(renderMath, 100);
                    }
                } catch (e) {
                    console.error("KaTeX rendering error:", e);
                }
            }

            // --- Глобальные переменные ---
            let currentModel = 'driven';
            let animationFrameId = null;
            let simState = null;
            let chart = null;
            let chartData = {
                labels: [],
                datasets: [{
                    label: 'Рассинхронизация ($\Delta$)',
                    data: [],
                    borderColor: 'rgb(239, 68, 68)', // red-500
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0,
                    tension: 0.1
                }]
            };
            let time = 0;
            const dt = 0.016; // Шаг времени (около 60 FPS)
            let simulationSpeed = 1.0;
            let modelParams = {};

            // Новые переменные для замедления графика
            let chartUpdateCounter = 0;
            const chartUpdateFrequency = 5; // Обновлять график каждый 5-й кадр

            // --- Элементы DOM ---
            const modelButtons = document.querySelectorAll('.model-button');
            const paramsContainer = document.getElementById('params-container');
            const descriptionPanel = document.getElementById('description-panel');
            
            const startButton = document.getElementById('start-button');
            const stopButton = document.getElementById('stop-button');
            const resetButton = document.getElementById('reset-button');
            const perturbButton = document.getElementById('perturb-button');
            
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            const perturbSlider = document.getElementById('perturb-slider');
            const perturbValue = document.getElementById('perturb-value');
            const diffValueDisplay = document.getElementById('diff-value-display');
            const autoscaleCheckbox = document.getElementById('autoscale-checkbox');

            const canvasRef = document.getElementById('canvas-ref');
            const ctxRef = canvasRef.getContext('2d');
            const canvasPert = document.getElementById('canvas-pert');
            const ctxPert = canvasPert.getContext('2d');

            // --- Шаблоны HTML (Параметры и Описания) ---

            const modelTemplates = {
                'driven': {
                    params: `
                        ${createSlider('gamma', 'Затухание ($\gamma$)', 0, 1, 0.2, 0.01)}
                        ${createSlider('f', 'Сила ($F$)', 0, 2, 0.5, 0.01)}
                        ${createSlider('omega_d', 'Частота силы ($\omega_D$)', 0, 2, 0.667, 0.01)}
                        <div class="w-full h-4 bg-gray-700 rounded relative overflow-hidden mt-2">
                            <div id="force-indicator" class="h-full bg-blue-500 absolute" style="width: 0%; left: 50%;"></div>
                        </div>
                    `,
                    description: `
                        <h3 class="text-md mb-2">Приводной маятник (синхронизация)</h3>
                        <p class="text-sm text-gray-400 mb-4">
                            Эта модель демонстрирует <strong>диссипативную систему</strong> (с затуханием)
                            со стабильным предельным циклом. Внешняя сила "приводит" маятник в движение,
                            а затухание стабилизирует его.
                            Даже если мы вносим возмущение во вторую систему, она в конечном итоге
                            "притягивается" к той же траектории, что и эталон. Рассинхронизация
                            экспоненциально уменьшается.
                        </p>
                        <p class="text-sm text-gray-400 mb-2">
                            <strong>Тонкий момент:</strong> Схождение происходит потому, что система
                            постоянно теряет энергию (из-за затухания $\gamma$) и "забывает" свое
                            начальное состояние, стремясь к единственному аттрактору, заданному
                            внешней силой.
                        </p>
                        <p class="text-sm text-gray-400 mb-4">
                            $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = F \\cos(\\omega_D t) $$
                        </p>
                        ${getLyapunovExplanation('negative')}
                    `
                },
                'simple': {
                    params: `
                        ${createSlider('l', 'Длина ($L$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('m', 'Масса ($m$)', 0.5, 2, 1, 0.1)}
                    `,
                    description: `
                        <h3 class="text-md mb-2">Простой маятник (стабильность)</h3>
                        <p class="text-sm text-gray-400 mb-4">
                            Идеальный маятник без трения и внешней силы (<strong>консервативная система</strong>).
                            Две системы, запущенные с немного разными начальными условиями,
                            будут колебаться вечно. Расстояние между ними в фазовом пространстве
                            не растет и не уменьшается, а остается в среднем постоянным.
                        </p>
                        <p class="text-sm text-gray-400 mb-2">
                            
                            <strong>Тонкий момент:</strong> Вы можете заметить, что после возмущения
                            рассинхронизация ($\Delta$) не остается нулевой, а начинает медленно
                            колебаться и расти. Это <strong>не хаос</strong>, а <strong>линейный дрейф</strong>.
                            Причина в том, что это <strong>нелинейная</strong> система: период колебаний
                            маятника зависит от его амплитуды. У маятника с большей амплитудой
                            период длиннее, и он начинает "отставать" от эталона, что приводит
                            к дрейфу фаз.
                        </p>
                        <p class="text-sm text-gray-400 mb-4">
                            $$ \\frac{d^2\\theta}{dt^2} + \\frac{g}{L} \\sin(\\theta) = 0 $$
                        </p>
                        ${getLyapunovExplanation('zero')}
                    `
                },
                'double': {
                    params: `
                        ${createSlider('l1', 'Длина 1 ($L_1$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('l2', 'Длина 2 ($L_2$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('m1', 'Масса 1 ($m_1$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('m2', 'Масса 2 ($m_2$)', 0.5, 2, 1, 0.1)}
                    `,
                    description: `
                        <h3 class="text-md mb-2">Двойной маятник (хаос)</h3>
                        <p class="text-sm text-gray-400 mb-4">
                            Классический пример хаотической <strong>консервативной системы</strong> (без трения).
                            Движение непредсказуемо. Две симуляции, запущенные с почти
                            идентичными начальными условиями, очень быстро расходятся.
                            Любое, даже бесконечно малое возмущение,
                            приводит к экспоненциальному росту ошибки предсказания.
                            Это и есть "эффект бабочки".
                        </p>
                        <p class="text-sm text-gray-400 mb-2">
                            <strong>Тонкий момент:</strong> Эта система демонстрирует, что хаос
                            может возникать не только в сложных диссипативных системах
                            (как аттрактор Лоренца), но и в простых механических системах
                            всего с двумя степенями свободы, сохраняющих энергию.
                        </p>
                        <p class="text-sm text-gray-400 mb-4">
                            Уравнения Лагранжа для этой системы слишком сложны,
                            чтобы приводить их здесь, но они решаются численно.
                        </p>
                        ${getLyapunovExplanation('positive')}
                    `
                },
                'double_damped': {
                    params: `
                        ${createSlider('l1', 'Длина 1 ($L_1$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('l2', 'Длина 2 ($L_2$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('m1', 'Масса 1 ($m_1$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('m2', 'Масса 2 ($m_2$)', 0.5, 2, 1, 0.1)}
                        ${createSlider('gamma_d', 'Затухание ($\gamma_d$)', 0, 1, 0.1, 0.01)}
                        <hr class="border-gray-700 my-3">
                        ${createSlider('f', 'Сила ($F$)', 0, 20, 5, 0.1)}
                        ${createSlider('omega_d', 'Частота силы ($\omega_D$)', 0, 5, 1, 0.01)}
                        <div class="w-full h-4 bg-gray-700 rounded relative overflow-hidden mt-2">
                            <div id="force-indicator" class="h-full bg-blue-500 absolute" style="width: 0%; left: 50%;"></div>
                        </div>
                    `,
                    description: `
                        <h3 class="text-md mb-2">Приводной двойной маятник</h3>
                        <p class="text-sm text-gray-400 mb-4">
                            Это <strong>диссипативная и приводимая</strong> версия двойного маятника.
                            Мы добавили член затухания ($\gamma_d$), пропорциональный
                            скорости, и <strong>внешнюю силу $F \\cos(\\omega_D t)$</strong>,
                            которая (упрощенно) приложена к первому грузу.
                        </p>
                        <p class="text-sm text-gray-400 mb-2">
                            В зависимости от параметров ($F$, $\gamma_d$, $\omega_D$),
                            система может иметь <strong>разные аттракторы</strong>:
                            от простой точки покоя (если $F=0$) до сложных
                            предельных циклов или даже <strong>странного аттрактора</strong>
                            (демонстрируя хаос).
                        </p>
                        <p class="text-sm text-gray-400 mb-4">
                            Поскольку эта система диссипативная, любые траектории
                            в конечном итоге "забывают" свои начальные условия и
                            притягиваются к общему аттрактору. Если этот аттрактор
                            - простой цикл, мы видим синхронизацию ($\lambda < 0$).
                            Если это странный аттрактор, траектории сходятся
                            к нему, но на самом аттракторе остаются хаотичными
                            ($\lambda > 0$).
                        </p>
                        ${getLyapunovExplanation('positive')}
                    `
                }
            };
            
            function getLyapunovExplanation(type) {
                let text = `
                    <h4 class="text-md mb-2 mt-4">Что такое показатель Ляпунова?</h4>
                    <p class="text-sm text-gray-400 mb-2">
                        Показатель Ляпунова ($\lambda$) — это мера того, как быстро
                        расходятся две близкие траектории в системе. Он показывает
                        чувствительность к начальным условиям.
                    </p>
                `;
                if (type === 'negative') {
                    text += `
                        <p class="text-sm text-gray-400">
                            <strong>$\lambda < 0$ (Стабильность):</strong> Системы "притягиваются". 
                            Любое возмущение со временем затухает. Рассинхронизация
                            уменьшается экспоненциально. Система предсказуема.
                        </p>`;
                } else if (type === 'zero') {
                     text += `
                        <p class="text-sm text-gray-400">
                            <strong>$\lambda = 0$ (Нейтральная стабильность):</strong> 
                            Системы не расходятся и не сходятся. Ошибка не растет
                            экспоненциально. Пример: идеальный маятник или планетарная орбита.
                        </p>`;
                } else if (type === 'positive') {
                    text += `
                        <p class="text-sm text-gray-400">
                            <strong>$\lambda > 0$ (Хаос):</strong> Системы "отталкиваются". 
                            Любое мельчайшее возмущение растет экспоненциально. 
                            Предсказать поведение системы на сколько-нибудь долгий
                            срок невозможно.
                        </p>`;
                }
                return text;
            }

            function createSlider(id, label, min, max, value, step) {
                return `
                    <div class="flex justify-between items-center">
                        <label for="${id}-slider" class="text-sm text-gray-400">${label}</label>
                        <span id="${id}-value" class="text-sm text-gray-200 w-12 text-right">${value}</span>
                    </div>
                    <input type="range" id="${id}-slider" data-param="${id}" min="${min}" max="${max}" step="${step}" value="${value}" class="w-full slider-param">
                `;
            }

            // --- Инициализация ---

            function init() {
                // Инициализация Chart.js
                const chartCtx = document.getElementById('diff-chart').getContext('2d');
                chart = new Chart(chartCtx, {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            x: {
                                // display: false, // БЫЛО
                                // ticks: { display: false }, // БЫЛО
                                display: true, // ИЗМЕНЕНО: Показать ось X
                                ticks: { 
                                    display: true, // ИЗМЕНЕНО: Показать метки
                                    color: '#9CA3AF', // text-gray-400
                                    maxTicksLimit: 8, // Ограничим кол-во меток, чтобы не было слишком тесно
                                    autoSkip: true, // Автоматически пропускать метки, если их много
                                },
                                grid: { color: '#374151' }
                            },
                            y: {
                                // По умолчанию автомасштаб
                                grid: { color: '#374151' },
                                ticks: { 
                                    color: '#9CA3AF',
                                    maxTicksLimit: 6,
                                    // ИЗМЕНЕНО: "Умный" форматер для оси Y
                                    callback: function(value) {
                                        if (value === 0) return '0';
                                        const absVal = Math.abs(value);
                                        
                                        if (absVal >= 1000 || (absVal < 0.001 && absVal > 0)) {
                                            // Очень большие или очень маленькие
                                            return value.toExponential(1);
                                        }
                                        if (absVal < 0.1) {
                                            // 0.052 -> 0.052
                                            return value.toFixed(3);
                                        }
                                        if (absVal < 1) {
                                            // 0.523 -> 0.52
                                            return value.toFixed(2);
                                        }
                                        if (absVal < 100) {
                                            // 5.23 -> 5.2
                                            // 52.3 -> 52.3
                                            return value.toFixed(1);
                                        }
                                        // 523.4 -> 523
                                        return value.toFixed(0);
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });

                // Установка слушателей
                modelButtons.forEach(button => {
                    button.addEventListener('click', () => selectModel(button.dataset.model));
                });
                
                startButton.addEventListener('click', startSimulation);
                stopButton.addEventListener('click', stopSimulation);
                resetButton.addEventListener('click', resetSimulation);
                perturbButton.addEventListener('click', perturbSimulation); 
                
                speedSlider.addEventListener('input', e => {
                    simulationSpeed = parseFloat(e.target.value);
                    speedValue.textContent = `x${simulationSpeed.toFixed(1)}`;
                });
                perturbSlider.addEventListener('input', e => {
                    perturbValue.textContent = parseFloat(e.target.value).toFixed(2);
                });
                autoscaleCheckbox.addEventListener('change', toggleAutoscale);
                
                // Загрузка первой модели
                selectModel('driven');
                autoscaleCheckbox.checked = true; // Автомасштаб по умолчанию
                toggleAutoscale();

                // Инициализация холстов
                resizeCanvases();
                window.addEventListener('resize', resizeCanvases);
                
                // Запуск рендеринга KaTeX (он вызовет сам себя с таймаутом)
                renderMath();
            }

            // --- Управление симуляцией ---

            function startSimulation() {
                if (animationFrameId) return; // Уже запущена
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function stopSimulation() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }

            function resetSimulation() {
                stopSimulation();
                time = 0;
                chartData.labels = [];
                chartData.datasets[0].data = [];
                chart.update();

                // Сброс состояния на основе текущих modelParams
                const p = modelParams;
                
                if (currentModel === 'driven') {
                    simState = {
                        ref: { theta: 0.5, omega: 0 },
                        pert: { theta: 0.5, omega: 0 }
                    };
                } else if (currentModel === 'simple') {
                    simState = {
                        ref: { theta: Math.PI / 2, omega: 0 },
                        pert: { theta: Math.PI / 2, omega: 0 }
                    };
                } else if (currentModel === 'double' || currentModel === 'double_damped') {
                    const initialState = [Math.PI / 2, 0, Math.PI / 2, 0]; // [th1, v1, th2, v2]
                    simState = {
                        ref: [...initialState],
                        pert: [...initialState],
                        traceRef: [], // ИЗМЕНЕНО: Хвост траектории для эталона
                        tracePert: [] // ИЗМЕНЕНО: Хвост траектории для возмущения
                    };
                }
                
                // Инициализация параметров
                updateModelParams();
                
                // Отрисовка начального состояния
                draw();
            }

            function perturbSimulation() {
                if (!simState) return;
                const magnitude = parseFloat(perturbSlider.value);
                
                if (currentModel === 'driven' || currentModel === 'simple') {
                    simState.pert.theta += magnitude;
                    simState.pert.omega += magnitude / 2;
                } else if (currentModel === 'double' || currentModel === 'double_damped') {
                    simState.pert[0] += magnitude; // th1
                    simState.pert[2] += magnitude; // th2
                }
            }
            
            function selectModel(model) {
                currentModel = model;
                
                // Обновление кнопок
                modelButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.model === model);
                });
                
                // Загрузка HTML
                paramsContainer.innerHTML = modelTemplates[model].params;
                descriptionPanel.innerHTML = modelTemplates[model].description;
                
                // Пере-инициализация KaTeX
                renderMath();
                
                // Установка новых слушателей для слайдеров
                document.querySelectorAll('.slider-param').forEach(slider => {
                    slider.addEventListener('input', handleSliderInput);
                });
                
                // Сброс симуляции
                resetSimulation();
            }

            function handleSliderInput(e) {
                const param = e.target.dataset.param;
                const value = parseFloat(e.target.value);
                modelParams[param] = value;
                
                // Обновление текстового значения
                const valueEl = document.getElementById(`${param}-value`);
                if (valueEl) {
                    const step = parseFloat(e.target.step);
                    const decimals = step >= 1 ? 0 : (step.toString().split('.')[1] || '').length;
                    valueEl.textContent = value.toFixed(decimals);
                }
                
                // Если симуляция остановлена, перерисовываем
                if (animationFrameId === null) {
                    draw();
                }
            }

            function updateModelParams() {
                // Считываем все слайдеры в modelParams
                document.querySelectorAll('.slider-param').forEach(slider => {
                    modelParams[slider.dataset.param] = parseFloat(slider.value);
                });

                // Особые параметры (g)
                modelParams.g = 9.81;
                modelParams.omega0_sq = 1; // Для приводного маятника
            }
            
            function toggleAutoscale() {
                const isEnabled = autoscaleCheckbox.checked;
                const scale = chart.options.scales.y;
                
                if (isEnabled) {
                    // Включить автомасштаб
                    delete scale.min;
                    delete scale.max;
                } else {
                    // ИЗМЕНЕНО: Зафиксировать текущий масштаб
                    const currentMin = chart.scales.y.min;
                    const currentMax = chart.scales.y.max;
                    scale.min = currentMin;
                    scale.max = currentMax;
                }
                chart.update();
            }

            // --- Главный цикл ---

            function gameLoop(timestamp) {
                const scaledDt = dt * simulationSpeed;
                time += scaledDt;
                
                // Обновляем физику
                updatePhysics(scaledDt);
                
                // Обновляем график (с замедлением)
                chartUpdateCounter++;
                if (chartUpdateCounter >= chartUpdateFrequency) {
                    updateChart(time);
                    chartUpdateCounter = 0;
                }
                
                // Рисуем
                draw();
                
                // Следующий кадр
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Обновление физики ---

            function updatePhysics(step) {
                if (!simState) return;
                
                // Считываем параметры каждый кадр (для "живого" обновления)
                const p = modelParams;

                if (currentModel === 'driven') {
                    const force = p.f * Math.cos(p.omega_d * time);
                    simState.ref = rungeKutta4(simState.ref, step, (state) => drivenDerivative(state, p, force));
                    simState.pert = rungeKutta4(simState.pert, step, (state) => drivenDerivative(state, p, force));
                    
                    // --- ИСПРАВЛЕНИЕ ИНДИКАТОРА СИЛЫ ---
                    const forceIndicator = document.getElementById('force-indicator');
                    if (forceIndicator) {
                        // forceRatio от -1 до 1
                        const forceRatio = p.f === 0 ? 0 : (force / p.f);
                        // barWidth от 0% до 50%
                        const barWidth = Math.abs(forceRatio) * 50;
                        
                        let left;
                        if (forceRatio >= 0) {
                            // Положительная сила: старт в 50%, ширина barWidth
                            left = 50;
                        } else {
                            // Отрицательная сила: старт в (50% - barWidth), ширина barWidth
                            left = 50 - barWidth;
                        }
                        
                        forceIndicator.style.width = `${barWidth}%`;
                        forceIndicator.style.left = `${left}%`;
                    }
                    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

                } else if (currentModel === 'simple') {
                    simState.ref = rungeKutta4(simState.ref, step, (state) => simpleDerivative(state, p));
                    simState.pert = rungeKutta4(simState.pert, step, (state) => simpleDerivative(state, p));

                } else if (currentModel === 'double') {
                    simState.ref = rk4DoublePendulum(simState.ref, step, p, doublePendulumDerivative);
                    simState.pert = rk4DoublePendulum(simState.pert, step, p, doublePendulumDerivative);
                    
                    // ИЗМЕНЕНО: Обновление обеих траекторий
                    updateTrace(simState.ref, simState.traceRef, p);
                    updateTrace(simState.pert, simState.tracePert, p);
                
                } else if (currentModel === 'double_damped') {
                    // НОВОЕ: Рассчитываем силу
                    const force = (p.f || 0) * Math.cos((p.omega_d || 0) * time);
                    
                    // ИЗМЕНЕНО: Передаем силу в функцию производной
                    simState.ref = rk4DoublePendulum(simState.ref, step, p, (y, p_in) => doublePendulumDampedDerivative(y, p_in, force));
                    simState.pert = rk4DoublePendulum(simState.pert, step, p, (y, p_in) => doublePendulumDampedDerivative(y, p_in, force));
                    
                    // НОВОЕ: Обновляем индикатор силы
                    const forceIndicator = document.getElementById('force-indicator');
                    if (forceIndicator) {
                        const forceRatio = (p.f === 0 || !p.f) ? 0 : (force / p.f);
                        const barWidth = Math.abs(forceRatio) * 50;
                        let left;
                        if (forceRatio >= 0) { left = 50; } 
                        else { left = 50 - barWidth; }
                        forceIndicator.style.width = `${barWidth}%`;
                        forceIndicator.style.left = `${left}%`;
                    }

                    // ИЗМЕНЕНО: Обновление обеих траекторий
                    updateTrace(simState.ref, simState.traceRef, p);
                    updateTrace(simState.pert, simState.tracePert, p);
                }
            }
            
            // ИЗМЕНЕНО: Вспомогательная функция для обновления траектории
            function updateTrace(state, trace, p) {
                const [th1, v1, th2, v2] = state;
                const { l1, l2 } = p;
                const x2 = l1 * Math.sin(th1) + l2 * Math.sin(th2);
                const y2 = l1 * Math.cos(th1) + l2 * Math.cos(th2);
                trace.push({ x: x2, y: y2 });
                if (trace.length > 200) {
                    trace.shift();
                }
            }
            
            // --- Физические модели (производные) ---
            
            // RK4 для { theta, omega }
            function rungeKutta4(state, dt, derivativeFunc) {
                const k1 = derivativeFunc(state);
                const k2 = derivativeFunc({ theta: state.theta + 0.5 * dt * k1.omega, omega: state.omega + 0.5 * dt * k1.alpha });
                const k3 = derivativeFunc({ theta: state.theta + 0.5 * dt * k2.omega, omega: state.omega + 0.5 * dt * k2.alpha });
                const k4 = derivativeFunc({ theta: state.theta + dt * k3.omega, omega: state.omega + dt * k3.alpha });

                const dTheta = (dt / 6) * (k1.omega + 2 * k2.omega + 2 * k3.omega + k4.omega);
                const dOmega = (dt / 6) * (k1.alpha + 2 * k2.alpha + 2 * k3.alpha + k4.alpha);

                return {
                    theta: state.theta + dTheta,
                    omega: state.omega + dOmega
                };
            }

            function drivenDerivative(state, p, force) {
                const { theta, omega } = state;
                const { gamma, omega0_sq } = p;
                const alpha = force - gamma * omega - omega0_sq * Math.sin(theta);
                return { omega: omega, alpha: alpha };
            }

            function simpleDerivative(state, p) {
                const { theta, omega } = state;
                const { l, g } = p;
                const alpha = -(g / l) * Math.sin(theta);
                return { omega: omega, alpha: alpha };
            }

            // RK4 для 4D вектора состояния [th1, v1, th2, v2]
            function rk4DoublePendulum(y, dt, p, derivativeFunc) {
                const k1 = derivativeFunc(y, p);
                const k2 = derivativeFunc(y.map((yi, i) => yi + 0.5 * dt * k1[i]), p);
                const k3 = derivativeFunc(y.map((yi, i) => yi + 0.5 * dt * k2[i]), p);
                const k4 = derivativeFunc(y.map((yi, i) => yi + dt * k3[i]), p);

                return y.map((yi, i) => yi + (dt / 6) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]));
            }

            // Производная для двойного маятника (вертикальная гравитация)
            function doublePendulumDerivative(y, p, force = 0) {
                const { l1, l2, m1, m2, g } = p;
                const [th1, v1, th2, v2] = y;

                const dth = th1 - th2;
                const c_dth = Math.cos(dth);
                const s_dth = Math.sin(dth);

                // ИЗМЕНЕНО: Полная замена на физически корректные уравнения
                // Источник: http://www.myphysicslab.com/pendulum/double-pendulum-en.html
                
                const den_common = 2 * m1 + m2 - m2 * Math.cos(2 * dth);

                const a1_num = -g * (2 * m1 + m2) * Math.sin(th1) - m2 * g * Math.sin(th1 - 2 * th2) - 2 * s_dth * m2 * (v2 * v2 * l2 + v1 * v1 * l1 * c_dth);
                // ИЗМЕНЕНО: Добавляем внешнюю силу (упрощенно, как ускорение)
                const a1 = (a1_num / (l1 * den_common)) + force;
                
                const a2_num = 2 * s_dth * (v1 * v1 * l1 * (m1 + m2) + g * (m1 + m2) * Math.cos(th1) + v2 * v2 * l2 * m2 * c_dth);
                const a2 = a2_num / (l2 * den_common);
                
                return [v1, a1, v2, a2];
            }

            // НОВАЯ ФУНКЦИЯ: Производная для двойного маятника с затуханием
            function doublePendulumDampedDerivative(y, p, force = 0) {
                // Сначала получаем производные без затухания
                // ИЗМЕНЕНО: Передаем силу (force) в базовую функцию
                const [v1, a1_base, v2, a2_base] = doublePendulumDerivative(y, p, force);
                
                // Считываем параметр затухания (с значением по умолчанию 0)
                const { gamma_d = 0 } = p;
                
                // Добавляем простое линейное затухание
                // ИСПРАВЛЕНО: Было a1, стало a1_base
                const a1_damped = a1_base - gamma_d * v1;
                // ИСПРАВЛЕНО: Было a2, стало a2_base
                const a2_damped = a2_base - gamma_d * v2;

                return [v1, a1_damped, v2, a2_damped];
            }


            // --- Обновление графика ---

            function updateChart(time) {
                let diff;
                if (!simState) {
                    diff = 0;
                } else if (currentModel === 'driven' || currentModel === 'simple') {
                    // Разница в фазовом пространстве (Евклидово расстояние)
                    const dTheta = (simState.ref.theta - simState.pert.theta);
                    const dOmega = (simState.ref.omega - simState.pert.omega);
                    diff = Math.sqrt(dTheta * dTheta + dOmega * dOmega);
                } else if (currentModel === 'double' || currentModel === 'double_damped') {
                    // Разница в фазовом пространстве (4D)
                    diff = Math.sqrt(
                        Math.pow(simState.ref[0] - simState.pert[0], 2) + // d_th1
                        Math.pow(simState.ref[1] - simState.pert[1], 2) + // d_v1
                        Math.pow(simState.ref[2] - simState.pert[2], 2) + // d_th2
                        Math.pow(simState.ref[3] - simState.pert[3], 2)  // d_v2
                    );
                }

                // Обновление текстового значения
                diffValueDisplay.innerHTML = `$\Delta = ${diff.toFixed(3)}$`;
                // Пере-рендеринг KaTeX для этого элемента
                if (window.renderMathInElement) {
                    window.renderMathInElement(diffValueDisplay, {
                        delimiters: [{left: "$", right: "$", display: false}],
                        throwOnError: false
                    });
                }
                
                // Добавление данных в график
                chartData.labels.push(time.toFixed(1));
                chartData.datasets[0].data.push(diff);

                // Ограничение истории
                const maxDataPoints = 500;
                if (chartData.labels.length > maxDataPoints) {
                    chartData.labels.shift();
                    chartData.datasets[0].data.shift();
                }

                chart.update();
            }

            // --- Отрисовка ---

            function draw() {
                // Очистка холстов
                ctxRef.fillStyle = '#1F2937'; // bg-gray-800
                ctxRef.fillRect(0, 0, canvasRef.width, canvasRef.height);
                ctxPert.fillStyle = '#1F2937'; // bg-gray-800
                ctxPert.fillRect(0, 0, canvasPert.width, canvasPert.height);
                
                if (!simState) return; // Не рисовать, если нет состояния

                if (currentModel === 'driven' || currentModel === 'simple') {
                    drawSimplePendulum(ctxRef, simState.ref);
                    drawSimplePendulum(ctxPert, simState.pert);
                } else if (currentModel === 'double' || currentModel === 'double_damped') {
                    // ИЗМЕНЕНО: Передаем обе траектории
                    drawDoublePendulum(ctxRef, simState.ref, simState.traceRef, 'ref');
                    drawDoublePendulum(ctxPert, simState.pert, simState.tracePert, 'pert');
                }
            }
            
            function drawSimplePendulum(ctx, state) {
                if (!state) return;
                const { theta } = state;
                
                // Используем параметры из modelParams, со значениями по умолчанию
                const { l = 1, m = 1 } = modelParams;

                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const scale = Math.min(w, h) / 3; // Масштаб
                const cx = w / 2;
                const cy = h / 2; // Точка подвеса

                const x = cx + (l * scale) * Math.sin(theta);
                const y = cy + (l * scale) * Math.cos(theta);
                
                const r = 10 + m * 5; // Размер груза

                // Стержень
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(x, y);
                ctx.strokeStyle = '#9CA3AF'; // gray-400
                ctx.lineWidth = 2;
                ctx.stroke();

                // Груз (с градиентом)
                const gradient = ctx.createRadialGradient(x - r*0.2, y - r*0.2, r*0.1, x, y, r);
                gradient.addColorStop(0, '#A5B4FC'); // indigo-300
                gradient.addColorStop(1, '#6366F1'); // indigo-600
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Точка подвеса
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#9CA3AF'; // gray-400
                ctx.fill();
            }
            
            function drawDoublePendulum(ctx, state, trace, type) {
                if (!state) return;
                const [th1, v1, th2, v2] = state;
                // Всегда используем актуальные параметры
                const { l1, l2, m1, m2 } = modelParams;

                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const scale = Math.min(w, h) / 5; // Масштаб
                const cx = w / 2;
                const cy = h / 2 - (l1 + l2) * scale * 0.2; // Точка подвеса
                
                const r1 = 8 + m1 * 4;
                const r2 = 8 + m2 * 4;
                
                const x1 = cx + (l1 * scale) * Math.sin(th1);
                const y1 = cy + (l1 * scale) * Math.cos(th1);
                const x2 = x1 + (l2 * scale) * Math.sin(th2);
                const y2 = y1 + (l2 * scale) * Math.cos(th2);

                // Траектория (хвост)
                if (trace) {
                    ctx.beginPath();
                    for (let i = 0; i < trace.length; i++) {
                        const p = trace[i];
                        const tx = cx + p.x * scale;
                        const ty = cy + p.y * scale;
                        if (i === 0) ctx.moveTo(tx, ty);
                        else ctx.lineTo(tx, ty);
                        
                        // Затухание альфа-канала
                        const alpha = i / trace.length;
                        // ИЗМЕНЕНО: Цвет в зависимости от типа симуляции
                        const color = (type === 'ref') ? 'rgba(60, 165, 250, 0.5)' : 'rgba(239, 68, 68, 0.5)'; // blue / red
                        ctx.strokeStyle = `rgba(${ (type === 'ref') ? '60, 165, 250' : '239, 68, 68' }, ${alpha * 0.5})`;
                    }
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Стержни
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = '#9CA3AF'; // gray-400
                ctx.lineWidth = 2;
                ctx.stroke();

                // Груз 1
                ctx.beginPath();
                ctx.arc(x1, y1, r1, 0, 2 * Math.PI);
                ctx.fillStyle = '#60A5FA'; // blue-400
                ctx.fill();
                
                // Груз 2
                ctx.beginPath();
                ctx.arc(x2, y2, r2, 0, 2 * Math.PI);
                ctx.fillStyle = '#34D399'; // green-400
                ctx.fill();
                
                // Точка подвеса
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#9CA3AF'; // gray-400
                ctx.fill();
            }

            // --- Утилиты ---

            function resizeCanvases() {
                const simWrapper = document.getElementById('simulation-wrapper');
                // Используем .clientWidth/Height, чтобы получить реальный размер
                const rect = simWrapper.getBoundingClientRect();
                
                const w = (rect.width - 16 * 3) / 2; // p-4 (16px) * 3 gaps (включая внешний)
                const h = rect.height - 16 * 2; // p-4 (16px) * 2
                
                [canvasRef, canvasPert].forEach(canvas => {
                    canvas.width = w;
                    canvas.height = h;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                });

                // Перерисовка после изменения размера
                draw();
            }

            // --- Запуск ---
            document.addEventListener('DOMContentLoaded', init);
        })();
    </script>
    
</body>
</html>

